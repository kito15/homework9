
Alright, everybody. So I wanna apologize for giving you a lot of information in the next hour or so. And this is a a there's a lot of different things going on in this project, this homework that's coming. And it's just gonna be a lot of information. So we're trying to keep it, but it's sort of like you gotta understand the whole thing because it's a big code.

Like, it's not big code base, but to you, it's gonna be a big code base. It's gonna be more code that you've seen and things done in different ways than what it has been up to now. So let me show you the program run, see show you what it does, and then we're gonna talk about it. And, basically, what we're gonna be going over is how to make data APIs. And let me the first thing is a lot of everything that you've been doing up to now has been getting you prepared to deal with working with this.

Like environment variables, logging, the object oriented programming, Docker. All these things are gonna are kinda coming together in this. And this is this program, what it does is it just creates QR codes and deletes QR codes through an API. Alright? And first, I'll show you how to do it, how it runs just to see what I'm talking about.

And then we're going to go through the concepts and the a bunch of different parts of this because you're gonna need to know a few things. Alright. 1st, let's just start it up. So And I'm using a script, start dot sh, and we'll come back and talk about that. But I just wanna show this.

So local host 8,000. This is what this page is, it's local host 8,000. It's like that's the default port that the application starts up on. The docs folder goes to this page. And what this page is is a it's called the open API spec.

And this is automatically generated by fast API as you add routes. And what this allows you to do see, when you make an API, you kinda have to imagine that you don't know who's gonna use it. Like, when you make a data API, you don't know who's gonna use it, and you almost have to think like you're talking to a blind person. And the only thing that they see is what you give them. And so they don't know anything about your API.

And and what this page is essentially meant to do is to provide the documentation to other developers on how to use your API and have a way for them to actually test it right in the in the web browser. So here, I can click on authorize, and then the default username is admin, and the password is secret. And these fields are optional. You don't need them. I just have to click okay, and I close this down.

Then what I can do is click try out. I can execute this, and then this this is what's called a get route. This is a get, and this is the route. Get QR code. So this is the URL that it's going to.

So if we went to and then it's listing out the QR code the URL of what the QR code links to, That's the URL of where it links to. This is a set of links related to the QR code. This is where you download it, and then this is the link and the data about the link to delete it. So this is known as a REST API, a Representational State Transfer API. And the if you would go to Twitter, This is just a pretty version of what we're looking at.

Okay? So all companies, all data, all things on the Internet for the last 15 years have been using what we call JavaScript Object Notation and Data APIs. K? Even when you go to web pages most of the web pages you ever go to, what they are is just the JSON data, the JavaScript object notation being sent to the web browser, and then there's a a JavaScript program in the web browser that downloads when you first go to the website. And then that JavaScript program renders the the JSON into the web pages you see.

Okay? The the days of, like, where we had web pages and we typed HTML into the web pages have been long gone. The days of generating those pages on the server side, we still use them use that technique in some cases for performance reasons. But for the most part, everything is done with data APIs. Because you gotta think that data APIs provide the raw data, the raw functionality, because the data API is essentially the intermediary between the client, which could be a mobile phone app, a refrigerator, a television, any device, and the database that's inside the company that they want, for some reason, to have act they want the clients to have some controlled access to.

So the data APIs provide the security. They send the data. They're really, really super important. You know how to make one. It's not that hard, but it's a lot of pieces.

Like, that's what we're gonna go through. How to use 1, You'll see more how to use 1 as as we go. It just takes longer to learn how to use it or how to make one than it does to use it. And a lot of people have already tried to use 1, but and the most and and, essentially, this is a back end software class. So you we're we're gonna take a while to be able to go through all the issues.

And you'll understand, like, in the future, whenever you wanna use somebody else's data API, it'll be real easy once you understand how to make a data API. So that's why we start off with this because it just takes longer to to do to to do this. And it's more valuable because this is what back end software engineers do. And the and some of you I know have mentioned to me and other kid people mentioned me that they wanna know React or they wanna know Angular or they wanna know this or that. If you don't know how to know a date how data API works and how to make one, all that's useless because that's exactly what React or Angular do is that they query the data API, and then they generate the web pages.

So if you don't have a data API, you can't do you can't do them. So you need to know this before you do anything else. Because it's it's you're you're not gonna you you you kind of it would be like trying to you you just couldn't work effectively because you can't make the full stack app. So let's go through the web page of the app, and then we'll get back to how to start it and how it works and all the all the pieces for it. So so let's give you a little history before we go to here, let's just do the little history lesson on how did we get here, how long have we been here, what's the history of this.

Because it's like knowing the history and being able to have a conversation historically about what's going on and has gone on in the tech industry is really important for making relationships with other technology professionals. Because the immediate assumption is that you don't know anything and your job is to prove that you know something. And one of those things to know is to know the history of where where the industry has been and how we got here. And you get a lot of points for that. Like, I actually has been and how we got here, and you get a lot of points for that.

Like, I actually think I got my investment in one of my start up companies because I knew the history of I had a Tandy TRS 80 and knew the history of computers. Because I was able to talk to the good investor, and then he understood that I wasn't just some kid that, just had an idea that I, like, knew the history of computers, like and that I had a good understanding of tech the technology industry, the history of it. Because in order to work in it and be effective, especially as a manager or decision maker, you really need to know the history of everything. You're kind of jumping in 25 years after an industry started. So it's like you gotta know what it is.

Anyway, so what this now APIs can be anything. API just stands for application programmer interface. We could be making a library in c sharp. We could be making a Java library. We could be using a Java library.

APIs or anything. What we're making is what's called a REST based web service web services. And the history of REST kinda works like this. The first guy there's a guy, Tim Berners Lee. And this is pretty quick.

And it's the Tim Berners Lee, when we talk about the Internet, the Internet is the network. K? The Internet is the network, the IP network that everything goes on. And then that was made by Vent Cerf, Bob, Kahn. These guys this guy these guys are basically the people that invented the Ethernet protocol and all the all the electrical engineering and computer science that runs the Internet.

They were part of ARPANET, which is the first network. Okay? That's not the World Wide Web. The World Wide Web was made by Tim Berners Lee. And what that is is specifically the HTTP protocol hypertext transfer protocol along with the h t and and that's a server.

And then the client, which is the browser, your web browser, and then HTML is the message format. So what that means is, like, the client connects to the server. The message format is the data that's being sent from the client to the server. And whenever we first made the Internet, we just had HTML, and that's what Tim Berners Lee made. And then that's that's where where it came from.

And in the HTTP protocol, it's made up of a bunch of different specifications. So a protocol is just an agreed upon an agreed upon definitions and processes of how to do something. Like, there where there would be open heart surgery protocol. There would be protocol to put out a fire, whatever. Okay?

And in here, we have a HTTP protocol, and that's made up of a series of specifications. And we don't really need to go through all this, but there's a few things that you need to know that are just like the rules of the road. So what happens is, and we can go back to here, is that there are HTTP verbs or methods, and they there's a few of them, but the basic ones that we deal with right now are gonna be get, put, post, and delete. And these are the actions that are specified in the request. K?

So it's like verb. And then the noun, in a in a way, that's what are you doing? So we're, like, getting QR codes from this address. And then where it says dash h, these are headers. So an HTTP message has a has a body and a payload.

The the the the sorry, has a body and a header. So the header is like what's on the outside of the envelope, and what's on inside is the payload. Okay? Generally, you can look at the headers, but you can't look at the payload. That's like the security thing that goes around on the Internet.

The so this is the destination. And then this has no body because it there's it there's nothing it but it has headers. So it's saying, hey. Look. I'm gonna authorize, and I'm gonna use what's called a bearer token.

And this is just a scrambled up text that can be decoded by the server. It's not encrypted. This isn't encrypted. This is just encoded. K?

So this is not this this is a there's a standard algorithm that would be able to and you'll see this where it turns that text into the username and goes back and forth, and it, like, it has data in it. And then but it's not encrypted. The encryption happens over HTTPS. So just to understand the Internet security model, you have HTTPS. You see the lock in the browser.

That's encrypted. Everything inside the encrypted is not encrypted, so everything else is in plain text. So the IP network, the Ethernet network, the, you know, the Internet, that's what provides the security. This is a protocol that lives within the Internet, and it has nothing to do with encryption. Alright?

And this token is part of what's called the OAuth authentication OAuth 2 authentication scheme, which we're we'll see in in a minute. So and then here's a response, and the response has a body. And then we have status codes. And 200, there's HTTP. There's a series of codes that are categorized, like anything 1 to a 100 is informational.

These are successful responses. These are redirections, meaning you went one place, and it's sending you to another. Like, it's forwarding you to another address somehow. These are errors on your client, like you're sending bad data, and this is the server broke. So you have you've seen messages like 404, the client requested a page not found.

That's the 404 error. You can see that, like and then there's standard ones. Like, they're they're they're just agreed upon. These are part of the specification, and this is just how HTTP works. And what you're doing is you're making essentially a custom HTTP server.

Your your server that you're making when you're making a web server, when you're at making this application, you're making a customized HTTP server that speaks HTTP protocol to clients that are requesting data from it. Alright? And the way you speak that is to know about the header, the status codes, the verbs, different parts of the HTTP protocol. And we're not going through the whole protocol. There's a lot of stuff.

But we're just going into, like, sort of as basic but as complete as I can show you. But it's like, it's a lot of stuff because you're talking about some security stuff. It's got encoding. It's gotta still do something. So we got the QR code thing.

But really, we only have 2 endpoints. So let's go back to here. So we have, like and so here's my get. Then here's the header. So that, basically, you always remember, you got your body, and then you got your headers, and then that kinda altogether makes up the request.

So, like, if I would read this, you could actually do this off the command line. So we could actually we might be able to run this because I might have curl installed on my computer. I haven't tried to do this, but we'll see. See if curl's here. So, yeah, it I was able to run it.

And, like, curl is a command line utility built into Linux that allows you to send a request to a web service. Curl is what does all the work in in a sense. Like, if we were gonna go and talk to open API API, we're gonna do everything. Like, once it's like the c program that's at the bottom of the stack that, like, it's what if you have Python and if you were had the Python language and you were making a request to a web service in Python, if you look down under the under the covers, like down in the side, it would be using curl. And then curl, you can there's a we're not gonna get into curl too much.

Like but I just wanna let you know, like, there's CURL is the core of making web service requests. And then you can take the request body here, and you can paste it in your command line as long as you're in Linux. And you can run that, and it'll get data back. K? There's a way to use curl through Python.

You would just be like curl Python, and then you'd basically do the same thing. It would be in a library that you'd be coding with rather than write off the. Now if I want to delete one of these now notice that this is a little feature of the program. I just want you to notice is that notice that that's the file name here, and let's go and see a QR code here. Actually, just say that that's the file name.

We'll well, I'll show you that demo in a minute. And then here, I wanna delete that. So I would put the do a tryout, put the put it in, execute it, and then what happens is is that's the request. This is the URL that this is what got told to do. And then this is actually the 204.

If you see a 2 this means it worked. Delete is funny because technically, it's supposed to just give you a 204 status code. And that 204 code is the message you need to know that it worked. Because 200 series like, 200 is like a get request is okay. A 201 is an inserts okay.

Like, if you're like, a 204 is the deletes the request work. See, like, the when something's deleted, there's nothing left, so it kinda doesn't send you anything back. Like, that's actually the part of the, what they call rest API specification, which we'll talk about in a little bit that I that's there's the thing that makes this sort of complicated is that there's these specifications that are industry standards for how these things have to work, and it kinda is what it is. It's like, if you don't write them to the specification, people won't be able to use your API. And that that and it makes it actually more difficult for you to to to work if you don't do things, like, exactly the way it needs to be.

Anyway and then if I wanted to create a QR code let me just roll this up so it's a little easier. And if I were to go just first of all, what would happen is I'll execute this, and the API is kinda smart. Oh, it doesn't have this. So it's it's good. So it says, QR code created successfully.

And then if I try to do it again, it's gonna say QR code already exists. So it's smart. It it it will know if it's already there. Then it won't recreate it. It'll just give you a link to the one that it has.

It is able to figure out the q this is a little trick. It is able to figure out the QR code existing is because when there's a thing called base 64 encoding, And we can use base 64 encoding to turn any text into including the contents of a file into a continuous stream of of text, of of of characters. Okay? And when we send data over the Internet, a lot of times, we have to send things in base 64 encoding. Like, I can send pictures in base 64 encoding.

I could send an audio, small audio file in base 64. There's different reasons why we wanna use it. And so what happens is is that that text here Let me go back to my if I take the file name and put this in there and the decode, it decodes it to the u r to the name of the website. See, we do the encoding in basics. This is like, hey, I could do base 64.

And this is one of the reasons why I'd wanna do this. So I want to be able to know what that QR code goes to, but I don't want to have to open the QR code up and try to figure out what the image is. That's going to be complicated. It's possible, but complicated. All I really care is that the QR code goes where I want.

And I want an easy way to tell whether or not that QR code is going where it needs to go. So we can't I couldn't could I save a file called this? Not really. This is going to break my file system. So I have to encode this into base 64, which is that text there, and then use that as the file name.

And then that way, if I look in the directory and you'll see this in the program. If I look in the directory and I'm like, are there any files with these names with this encoded, like this file name, then I know that that's already existing. And then I can send the user to get the one that already exists versus trying to create the new one. Does it make a little sense? So, like, let's just review this real quick because there's a few things going on here.

We got HTTP. HTTP is protocol. It runs on the Internet. The Internet's the network. HTTP protocol has got a bunch of different specifications to it.

The main stuff we need to know about HTTP is that it's got a body, it's got a header, it has, different fields in the header. 1 of the fields in the header can be a bearer token. The bearer token is, part of the security model that allows us to tell who the user is. It's not a login. It's just authorization.

It's authorizing see, there's authentication and there's authorization. Authentication is when you log in. Authorization is whenever you're checking whether or not the user can do something. So that bearer token is part of the authorization process on the API to make sure that you can actually do what you say you're trying to do. You could not have it.

But then the API endpoint would not have any security. It would just be a public API endpoint. And sometimes we do that, because you need to make it so that the API can respond to unauthenticated clients, clients that don't have authorization because it's public. Now Tim Berners Lee made the browser HTML and everything, and that was, like, circa 1990, late nineties late I mean, late eighties or, like, early nineties. Then a guy named Roy Fielding.

This guy, he wrote an important paper for his dissertation, which is Roy Fielding. And so his dissertation was architectural styles and design for network based software architectures, and this was done by Roy Fielding in 2000. And what Fielding did was to say, okay. The Internet had started to to boom. K?

And we had the dotcoms and everything. But the technology really wasn't there to have applications on the Internet because we were dealing with HTML. We're just we're trying to put Band Aids on it. And and and the but the business needs were ever increasing for the Internet, and the money involved in it was increasing. And so they needed to come up with he he his idea was, let's have a different idea of how we use the HTTP protocol.

And what he said was the HTTP protocol has a bunch of verbs, actions, doing things. Alright? And just for argument's sake for right now, just to keep it simple, there there's HTTP verbs of get, get, post, put, delete. And you'll see that there's a few other ones. There's patch.

And each one of these methods does a specific thing. And what he said is, you know what? Get, post, put, and delete, and patch sound a whole lot like database operations. Get the record, insert the record, update the record, update a field on the record because that's basically get gets records. All records are a single record.

Post inserts records, puts replace records, all the whole record. So if you had a person's name and address, you would have to replace the whole name and address. But if you have a patch, a patch would support being able to update the name or the address. It's it's at a field level. It's a modification of a resource, not a replacement of the resource.

And then delete, delete. And then each one of these has properties to it. K? And this is basically saying that you'll see that this is term idiopotent idiopotent. And essentially, this is saying that one successful request of this has the same effect as many requests.

So, like, once you delete it, it's gone. Like, it only can be done done once. You can cache it. You can't put it in a form. So these specifications, like, sort of detail out how everything needs to needs to work.

And, like, essentially, your job as a back end software engineer, for the most part, is gonna be figuring out how to make REST APIs that conform to these standards and making sure that it does things as expected so that other developers can use your API because it's a standardized way of working. It's not you don't invent nothing. You have to learn how to conform to the standard. So Fielding basically said, let's treat the Internet rather than a bunch of hyperlinks connecting web pages, which is what Berners Lee was saying essentially, which maybe he thought about this later, but he was thinking about web pages more. And field Fielding said, let's think of the Internet as a network of connected databases.

And that I forget if he said this specifically, but it it came at the same time. We're gonna use rather than using HTML, we're gonna use JSON, JavaScript object notation pretty much as the language of the Internet as as, of the message format. Because JSON at the time of 2000, HTML wasn't standardized, really. It wasn't XML. See, XML is a message format, and this is sort of the original mess message format.

We don't use this. I mean, people do use this in industry, but we're not doing this in this class. XML is very verbose. And if you had used Java, you would have end up encountering XML. And it's just a verbose old message format, which has some advantages for certain things.

It's used for certain things. I'm not saying it's a good thing or a bad thing. It's just old and widely used. But it's not used primarily on the Internet because JSON and the internet all go together because what JSON is this is the message format that the web server returns. We can see that on our web server that that's JSON and that it's a structured data.

It's structured into fields and arrays because, like, here, if we look at reading this, this the curly brace starts it, then you have key value pairs, and the bracket means array. And then you have here's the array of key value pairs of each record. So this is one record, another record. These are the links. All right?

And we And so what happened was Fielding came out with his dissertation, a lot of people read it, and they were like, wow, let's think about the internet differently. And pretty much the first major product that came out that leveraged Fielding's work was Google Maps. So you can see, like, Google Maps and So roughly started to be work it was I think, basically, they bought this company. Google Maps began as a C plus plus desktop program in 2004. And then in 2005, that's when Google made it.

And then when they made an API, that was Google Maps, and that was the JSON, and that was everything coming together. Okay? So I'm not I just wanna be clear to people. Okay? I'm not trying to make you know so much stuff because I'm just fun with this.

Like, it's just it's because it's 20 years we've been doing this. Do you understand? Like, it's 20 years. Like, if you don't understand how to do this, how to make an API, how to work with JSON, how to do this, this is like showing up to a party 20 years late. It's not acceptable.

And it kinda is what it is. Like, kind of what I'm getting at is that there are specifications. It has to work this way. Even though the codes not the codes are complicated. I'm gonna explain to you how to think about it and how to read it because it's gonna look like a maze of of of things happening.

It's it's but if there's a method to the madness, like, this is an like, I did it industry standard way of how this how this works, how it codes organized, how everything's put together. So let's go back and look at the response. And the other so the other thing that we gotta know about is it's like a a word, and you wanna stick this in your head because you're gonna need this when you talk to ChatGPT, is what's called. And so HADIOS is part of a REST API specification. So HADIOS, basically, it stands for hypermedia as the engine of application state.

Alright. So let's think about this, because this is gonna relate to stuff we've learned, and this is gonna hopefully sink in. Remember we were talking about state? Like and remember with state, you'd have a program running in memory or you could have a program running on secondary storage. And if we're gonna scale things, we can't have programs running in the memory of a computer because eventually, you run out of the vertical scaling.

Eventually, you just run out of resources vertically. So you've got to scale horizontally for a lot of things. Okay? In order to scale horizontally, you have to have stateless applications. Okay?

So no state. Hatios goes with this because Hatios is using hypermedia, meaning the data sent over HTTP, the JSON, to preserve and contain the state of the application. So the secondary storage is theoretically the the the message. Because, like, rest when I say rest API, it's an acronym. It says for representational state transfer.

So I'm transferring a representation of data somewhere in my database. I'm transferring that state of that data, the fields, the data in it. I'm transferring it, that state across the Internet over the network to a client, and then that client is able to interpret and take that state for its new state that it's gonna then process and that the we don't save anything in between. Like, here's the database. You create a response.

That's the state of the database for that request of whatever was needed. That state is then transferred over to the client, and the client then interprets that state and does whatever the client is supposed to do with the state. And Hatios is the more precise definition of what's going on in a way because it's saying hypermedia as the engine of application state, and it's what it's saying is here that I'm gonna have a response, and it's gonna have this data about the response. But we're also gonna have this links area. And the links area says any links that relate to this record.

So these links would be this is the if I was reading this and I was, let's say, a client like a web browser, then I would know what other URLs to put in the user interface that could access these. So it's like, in our case, if we were to make a web client, we would know that if we're going to display like a link to view it, then we would use this link. And then this is the link in the HTML to view the resource. In here, we would know if we were gonna put a delete link in the user interface that this is the link to go and delete it and that it has to be sent as a delete method with application data JSON, like JSON text to do this. So like representational state transfer, that's the REST API.

But what essentially tells you what has to be in the messages, what has to be in the responses is. If you had ever been trying to make a REST API before for some reason and you didn't know that what was to do it to do it the exact right way, I just enlightened you. Because that is not the most obvious thing to just come on to your own to figure out that this is how it has to has to go together. And so let's see how this works. Like, how does this program work?

So right now, it's running, and I'm gonna stop it. I'm gonna do a clear. And this is kind of like driving a school bus where you got gas and brake and clutch, and you gotta, like, you're driving a manual car. You gotta know when to do what. And there's sometimes you're gonna do one thing, and sometimes you're gonna do another.

Because the way this program is architected is that there's really, like, I don't know, 3 or 4 ways to start it depending on what you're trying to do. I wanna show you the the Docker file. And then we're gonna start it up using Docker. And I'm gonna show you what all this does. So here is fast API is our Python program.

And what it's doing is just setting the QR code directory. It's sharing the QR code. It's like what we were doing before on the command line. Okay? Except now we're gonna have this run as a server.

And then we have a Dockerfile that it's gonna build, and this is the this is the dot yield Dockerfile that it's gonna build, which we'll get into in a little bit. But we also have another service, which is NGINX, and NGINX is the most popular web server. But it it does other things. And in this architecture, we need 2 different services. K?

So kind of think about the use case. Imagine we have a company. And this is why I'm making it. Not why I'm making it, but, like, I'm gonna use this in this use case, and I think we're gonna be doing this for class. Class.

We wanna have events, and this is gonna be fun. We wanna have events, and we wanna be able to make web pages that have QR codes on them so that whenever somebody scans the event with the QR code, that we can register someone for the event. K? That it takes them to the website. Makes sense?

We're gonna get a lot more people viewing web pages, And we don't want our REST API to have to serve files. It's not to serve files. The REST API, our Python program, is supposed to generate QR codes and delete QR codes. It's supposed to manage them. It's not supposed to be the public face of it.

It's because we got to have the QR codes that will eventually go to web pages. All right? So generally, you don't want your API serving files, like sending big files. Because when a file is loaded into the program, it has to take all the men like, it'll take all the memory in the computer for each file being loaded as it's getting sent, and it gets really bad. Like, it's a a bad idea.

So if you have files, you have to use NGINX. And usually NGINX, we use as what we call a proxy to Python applications anyway. So NGINX, what we're gonna see here is that it has a simple configuration, and that configuration just says, when you go to the downloads folder, go this downloads folder goes to QR codes folder, and then this is just an option to show you an index. And then here, this says whenever you go to slash, this is gonna send us to our fast API program. I know that it's called fast API here because inside Dockertown, we refer to other services by their service name.

So the service name, you can think of that as its DNS name. So here, fast API, when I go to Docker Compose, that's that. If I changed it to that, then I'd have to change the connect I'd have to just change over there, but I don't wanna do that. Okay? Because, like, this has to match this.

So let's start this up using Docker. Let me start my Docker up. Now what I'm gonna do is and what this is what you gotta pay attention to because, like, people don't people don't pay attention. If I'm gonna go to local host, just local host, not the 8,000. If I'm doing local host 8,000, if you see that in your URL, that is whenever you're running the program without Docker.

That's just fast API running on your computer without any Docker whatsoever. So port 8,000 locally, that's if you started it up manually. Like, you didn't use Docker at all. But whenever you use a Docker, then it is hosted in local host. And if you and it you have to go to local host docs.

And then now you would see the whole program. So now we could do get I do authorize and do admin secret authorize. Close, try it out, execute. So now I get these links, and now these links, because they're gonna be hosted off Vengenix, they'll load. Okay?

Now I'm just gonna open up another I'm gonna control c this. So one way is to start it up with Docker, and that's like the full program. That's like, if you don't start it up with Docker, NGINX is not working. You won't be able to see the QR code because the QR codes come from NGINX, like the actual hosting of them. But the so so you won't you can run the app.

Like, I can do and I I put a couple commands in here. Like, I can do this command, And this is it running locally on port 8,000. And if I do that and go to but I'm running it on the 8,000. It's not gonna there's no like, I can I can retrieve the QR codes when it says say not authenticate? So admin.

If I try to do this now, that shouldn't. Maybe I have NGINX running or something. Yeah. That, that was just cash That was like in the, that was being saved. So that's, this, this doesn't exist anymore because like the NGINX isn't, isn't running.

I was like, think I'm going crazy. The, now back to how we run this. When you clone this repo, one of the things that you're gonna need to do is you're gonna need to do a chmodu+xonstart.sh. Because you're gonna wanna be able to use like, the the command to start this up is kinda long. Like and what I did and you do this with Docker a lot.

And I would highly recommend you go look into just as, like, a side, like As soon as you have spare time, you need to go learn bash scripting. K? All bash scripting you gotta understand bash is the terminal you're typing the commands into. So all bash scripting is is those commands. It's just like there's an interactive Python interpreter.

Well, there's an interactive bash, and the bash is just to deal mainly with the file system and your and control and your operating system. Okay? So it's not rocket science. So what you do is I make a start dot sh file. You have to put a thing called a shebang at the top.

And then you can just type the commands that you would normally type on the terminal in here. And as long as you do that chmoduplusx, as long as you do this, then it will run. See, if I do a ch I'm going to take it back to not user execute. Like, I'm going to take it to the default state for you. If I type in st, it won't even complete the command because it knows that it can't run this.

It can't do anything with it. If I do chmod, I'll just go up, and I do that, then if I do I could hit the tab key, and it auto complete. So at a very basic level, all bash is just putting a file, a text file, put the shebang at the top, and then type whatever you want to run as a command in here. And it's pretty so easy to figure this out. And because you already maybe know command line stuff, if you just go look at the basics of, like, Bash to teach you how to do loops, to teach you how to do some variables, stuff like that, it'll greatly increase your employability.

And just it allows you to automate stuff. It's just super important to learn Bash. Alright. So there's 2 ways like I said, there's, like, 3 ways to start this. One way to start it is we're using the the theuvicorn option with reload.

And UV corn is a single Python web application server. It's 1. In UVicorn, with the reload, what it does is that if I have my app and I'm just going to make a change here. If I hit a space, it'll reload. So this is what we call hot reloading.

So it monitors the code. And when I make a change, it'll reload the program so that you can test it. But we wouldn't wanna run this like this in what we call production. We're gonna wanna run it using what we call gunicorn. And gunicorn, I always tell people what's funny because, like, I thought it was funny.

Gunicorn. If you wanna become a hacker or a cloud engineer or pretty much anything in IT, learning bash, learning this skill will make you awesome. It will take you to the next level, giving you the power to automate things like hacking networks, but faster creating virtual machines in the cloud, but just faster. Essentially, this will make you a better nerd. And if you can learn to wield this power, it will make you, well, powerful.

Yeah. He's really excited about Bash. He's he's a real network Chuck. That guy on t on on YouTube, network Chuck on YouTube, killer YouTube. He's some of the best networking and best tech videos there are.

And I just wanna show you Gunicorn. Gunicorn is green unicorn. And what it is is a WSGI HTTP server. It's Long story short, just to kind of like and I just want to show you what it is, because it's like one of those pieces of information you may need to stick in your head and use one day. But I don't know.

See, uvicorn is 1. But gunicorn is being able to start up a swarm of them, basically, what they call workers. So, like, if I start this with gunicorn so, like, I'm gonna I'm gonna put the pound sign there and turn that off and use this. If I start this up this way, if I do start sh, this is using gunicorn. And what happens is is that you see the dashw4?

This is creating 4 copies of this application server so that if I had multiple cores and more resources, it can parallel process requests coming in. So So they all go to the gunicorn server. And then internally, the gunicorn server is routing to different copies of the application running on different cores on your or threads on your on your computer. K? Like, it's levels of horizontal scaling.

Like, you have horizontal scaling at the at the server, at the machine level. That's kinda like this running multiple copies. You have horizontal scaling at the copies of the machines, the copies of the Docker image. So it's like a pyramid of horizontal scaling between the machine images, the software that's running, the programming of your software of how it's horizontally scaling. It's just a series of different techniques in horizontal scaling.

And that's if you're gonna be a back engine back end engineer, that's kind of what your bread and butter knowledge is, is that sort of system of horizontal scaling and vertical scaling of when to use 1 and when to use the other and different techniques to do it. So let's see how this program works. See, here, it doesn't have like fast reload. It's setting it's starting it up. Like, see, like, booting workers, these are 1, 2, 3, 4.

These are 4 separate workers within the gun of corn, which are copies of the program running. And I'm gonna make a real quick change to my Dockerfile because I'm just gonna change this to entry point. And let me just do a every time I like to do a test to make sure we're all firing up. Yeah. And so this is now running Docker with the gunicorn.

See, this is the gunicorn gun of corn output. If I run and run it with the the reload one, that's like, I can do this. And so this is running with the the unicorns, which is the with the fast reload, the hot reload. And you can do kinda cool stuff with this. See, I can run Docker.

And then because I'm sharing my app volume, because I'm sharing my local directories with the app that's running inside the Docker container, if I make a change here, it's it's picking it up. So, like, this is running in Docker. This is the full application running, but I can make a change on my local through PyCharm or not PyCharm, but by Versus Code. And then it senses that, and it reloads it. And, essentially, that volume sharing right here, this line right here, this is what's connecting my local into the Docker image Docker container that's running that image.

So it that's the bridge between the 2. And this is a really good way to run the program except only whenever you're doing development. Like, you kinda have to remember to switch back and forth the start command. Or there's some ways that we could do this with bash scripting where if you had an if statement, it would say, like, if environment variable called, like, environment was called we we there's ways we could make we could automate this to make it work a little smoother. I might do that in the future.

Alright. So did does it seem like a lot of information? Yeah. But it's like this is how it is. Like, that that's the how should I put this?

We haven't even looked at the code yet. Like, this is, like, why, like, one of the reasons, like, people wonder why they don't get called back on jobs is because you need to be able to to communicate through your skills that you know a certain set of skills that relates to this, like the bash scripting, the docker, the right libraries like Pydantic, FastAPI, these different things. Because when somebody looks at that, then they're able to, like, oh, I could at least put this person in the driver's seat, and they could drive the bus of what I'm needing them to do. But if you don't have the right skill set on there, they can see that you're just missing information that's going to make it almost impossible for you to drive the bus effectively. Alright.

So let's just go over, like, the way the code works. We're not going to go over too much. But it it's the way you have to think about this is the way I like to think is it's follow the bouncing ball. And what I mean, like, if if you don't know that metaphor, it's like follow. So what we're gonna do now is we're gonna follow the bouncing ball.

On the same page. And trace through each step of execution because that's sort of like, you know, it's like, I know I'm not good at fixing a car, but I know electric. I know you need a s, and you need a s. So I just know that you gotta have a set and set of things. They all gotta work together or else the cars are fixed.

A certain set of dates. They all got words together or else. You're so ready. So the way this works is you have the app folder. You got main dot py.

Okay. Main.py. Alta's is you got some importing. We set up our logging. We create a QR code directory if it doesn't exist because, like, it needs to queue it needs to make sure it's got a QR code directory to do this.

All this is is just some metadata to set up, like, the name of the application. This is all the stuff that whenever we look at that fast API screen, at the open API spec, when we look at that, that's what's on the header, like the name of the program, just basic information. Then here is the router. So the router is where our routes are. On our routes are where each URL, each command essentially, is for the application.

So I have an OAuth router, which we'll talk about later, and then we have a QR code router. So we're gonna go to QR code router. And and the easiest way to do this is press the control key down and hover over the link or hover over the code and click on it. It'll take you to there. Once we do this, then it's import a bunch of directories, and then the real meat of this is the code down here.

So for instance, here is here's the route. This is the object. Post. K. So this is a post method.

This is the URLs, and this is the the this after the base. So it's like local host whatever slash QR codes. This is specifying how you want your response to be returned, and, like, we could look into there. And then this is defining the response in for JSON. Basically, this is like setting up what data is gonna be sent back and the format of that data that's gonna be responded to whenever this is done.

And this is a bunch of stuff that relates to the fast API to the opening API spec to give, like, demonstrations of this. And these are just different these are the fields. So like these are the links. This is the QR code URL. So this is the data that's going to be sent in the response.

Let me go to routes. This is saying that this is the status code. So, basically, this line is specifying what's the route. What does the response look like? Like, what's data is gonna be what like, what data how does that data have to be formatted?

If the data isn't formatted the way the model wants, and it'll give you an error in the program. It'll tell you, like, the model the data is not right. And then here's the status code that we want whenever the QR code is created. Now, this is the function that's doing it. So it's like this takes an incoming request of a QR code request, and we can take a look at that.

So a QR code request looks like this. It's gotta have a URL, a fill color, and a size. So these are the fields that the request has to take in. And then this is just this is saying this depends on OAuth, which is the security scheme. This is just saying, hey.

This thing has to have a bearer token. This thing this this route is protected with a password, basically. And we'll go into this later, but that's just what that part means. And then from there, it's about making the QR code. So we gotta do the logging.

Like, we're saying, hey. You wanna we're starting to make a QR code. Because it's like you don't know what's going on. Like, you gotta kinda see this program's big. This is just one route.

There's a lot of stuff going on in here. That's why that logging is real important, because you've got to be able to say what's happening. And sometimes, like, I had a 4 hour problem the other day. And the only way I figured it out was doing logging to figure out when something was starting and when something was not starting because it was not doing it, and it wasn't giving me any error. And I had to find out exactly where it was not doing something even though it wasn't telling me anything.

It just wasn't working. It was driving me nuts. But logging is what allowed me to, like, say, oh, this function got called. This function got called. This started.

This started. Logging helps you with the debugging. Anyway, so here is encoding the file name. This is doing the base 64 encoding of the URL. And here, we're making the file name.

Here, this is the path of where the file's name is gonna be. Now we're just making we're making a URL for that QR code, so this is the link that's gonna be sent back. Here, we're generating links because this is the. It's common, and it kinda tells you this is we gotta do that thing where we're providing links to other resources for related to this. So that's what that's what's happening here.

Then here, we're just checking, does it does it exist? And then if it does exist, then we're logging. QR code already exists, and we return back the QR code, the links that we generated, and the status code to say this thing already exists. So we check it here. If it passes this check, then here, we're generating a new QR code, and then we're populating our respond our our QR code response across here, and then we return it back.

And then here is the get route for getting a list of all the QR codes, and then here's the delete route for all the QR codes. And the way the code is basically organized is routes routes go in the router folder in some file here. So routes are the URLs. Think of it like that. Those are the commands.

Services, there's a QR service. Anything external to your program, like a database or the file system, anything that's outside of your control, that's a service. So external resources or services like the the the file system is a service. Your database is a service. So you organize your code because you gotta kinda see that, like, you really don't you couldn't put all of these things in one route.

Like, there it it's too big. And then you have to reuse it. So you have to have a place to reuse your services. You don't wanna have copies of file operations in all of your routes. You need a central place to code to put code that is for, you know, database or whatever you're doing to organize yourself.

So they call that a service. Then there's a utils folder. And then utils has and I could break this up, but I just keep sticking functions in here. And utils is just where I put all my general general functions, like setting up logging, how do I authenticate a user, Creating an axe creating one of those JWT tokens that we'll talk about later. This is some security stuff just to validate and sanitize URLs so that you it's like making sure that they're not having stuff that'll break your computer.

And this is the encoding and decoding of the URL, the file name in the base 64. You see that? This is where we're generating Hatiels links. Okay? So I apologize.

It's a lot of information. And then we're gonna go over more of it on Thursday or the next class the the next recording. So I'm just gonna shut this down for here at all.